/////////////////////////////////////////////////////////////////////
//
//	PdfFileWriter
//	PDF File Write C# Class Library.
//
//	PdfObject
//	Base class for all PDF indirect object classes.
//
//	Uzi Granot
//	Version: 1.0
//	Date: April 1, 2013
//	Copyright (C) 2013-2019 Uzi Granot. All Rights Reserved
//
//	PdfFileWriter C# class library and TestPdfFileWriter test/demo
//  application are free software.
//	They is distributed under the Code Project Open License (CPOL).
//	The document PdfFileWriterReadmeAndLicense.pdf contained within
//	the distribution specify the license agreement and other
//	conditions and notes. You must read this document and agree
//	with the conditions specified in order to use this software.
//
//	For version history please refer to PdfDocument.cs
//
/////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;

namespace PdfFileWriter
	{
	/////////////////////////////////////////////////////////////////////
	// Resource code enumeration
	/////////////////////////////////////////////////////////////////////
	internal enum ResCode
		{
		// must be in this order
		Font,
		Pattern,
		Shading,
		XObject,
		ExtGState,
		OpContent,
		Length
		}

	internal enum ObjectType
		{
		Free,
		Other,
		Dictionary,
		Stream,
		}

	internal enum XRefObjType
		{
		Free,
		InFile,
		ObjStm,
		}

	////////////////////////////////////////////////////////////////////
	/// <summary>
	/// PDF indirect object base class
	/// </summary>
	/// <remarks>
	/// PDF indirect object base class.
	/// User program cannot call it directly.
	/// </remarks>
	////////////////////////////////////////////////////////////////////
	internal class PdfObject : IComparable<PdfObject>
		{
		/// <summary>
		/// PDF document object
		/// </summary>
		public PdfDocument Document { get; internal set; }

		/// <summary>
		/// Scale factor
		/// </summary>
		/// <remarks>Convert from user unit of measure to points.</remarks>
		public double ScaleFactor { get; internal set; }

		internal int ObjectNumber; // PDF indirect object number
		internal string ResourceCode; // resource code automatically generated by the program
		internal long FilePosition; // PDF file position for this indirect object
		internal ObjectType ObjectType; // object type
		internal XRefObjType XRefType;
		internal int StrmParent; // parent object number
		internal int StrmIndexNo; // index within parent
		internal List<byte> ObjectValueList;
		internal byte[] ObjectValueArray;
		internal PdfDictionary Dictionary; // indirect objects dictionary or stream dictionary
		internal bool NoCompression;

		private static string[] ResCodeStr = { "/Font <<", "/Pattern <<", "/Shading <<", "/XObject <<", "/ExtGState <<", "/Properties <<" };
		internal static string ResCodeLetter = "FPSXGO";

		internal PdfObject() {}

		////////////////////////////////////////////////////////////////////
		// Constructor for objects with /Type in their dictionary
		// Note: access is internal. Used by derived classes only
		////////////////////////////////////////////////////////////////////

		internal PdfObject
				(
				PdfDocument Document,
				ObjectType ObjType = ObjectType.Dictionary,
				string PdfDictType = null   // object type (i.e. /Catalog, /Pages, /Font, /XObject, /OCG)
				)
			{
			// save link to main document object
			this.Document = Document;

			// save type
			ObjectType = ObjType;

			// save scale factor
			ScaleFactor = Document.ScaleFactor;

			// no compression
			NoCompression = Document.Debug;

			// switch based on object type
			switch(ObjectType)
				{
				case ObjectType.Free:
					XRefType = XRefObjType.Free;
					break;

				case ObjectType.Other:
					XRefType = XRefObjType.ObjStm;
					ObjectValueList = new List<byte>();
					break;

				case ObjectType.Dictionary:
					XRefType = XRefObjType.ObjStm;
					Dictionary = new PdfDictionary(this);
					break;

				case ObjectType.Stream:
					XRefType = XRefObjType.InFile;
					Dictionary = new PdfDictionary(this);
					ObjectValueList = new List<byte>();
					break;
				}

			// if object name is specified, create a dictionary and add /Type Name entry
			if(!string.IsNullOrEmpty(PdfDictType)) Dictionary.Add("/Type", PdfDictType);

			// set PDF indirect object number to next available number
			ObjectNumber = Document.ObjectArray.Count;

			// add the new object to object array
			Document.ObjectArray.Add(this);
			return;
			}

		////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Compare the resource codes of two PDF objects.
		/// </summary>
		/// <param name="Other">Other PdfObject</param>
		/// <returns>Compare result</returns>
		/// <remarks>
		/// Used by PdfContents to maintain resource objects in sorted order.
		/// </remarks>
		////////////////////////////////////////////////////////////////////
		public int CompareTo
				(
				PdfObject Other     // the second object
				)
			{
			return string.Compare(ResourceCode, Other.ResourceCode);
			}

		////////////////////////////////////////////////////////////////////
		// Convert user coordinates or line width to points.
		// The result is rounded to 6 decimal places and converted to Single.
		////////////////////////////////////////////////////////////////////

		internal float ToPt
				(
				double Value // coordinate value in user unit of measure
				)
			{
			double ReturnValue = ScaleFactor * Value;
			if(Math.Abs(ReturnValue) < 0.0001) ReturnValue = 0;
			return (float) ReturnValue;
			}

		////////////////////////////////////////////////////////////////////
		// Round unscaled numbers.
		// The value is rounded to 6 decimal places and converted to Single
		////////////////////////////////////////////////////////////////////

		internal float Round
				(
				double Value // a number to be saved in contents
				)
			{
			if(Math.Abs(Value) < 0.0001) Value = 0;
			return (float) Value;
			}

		internal void ObjectValueAppend
				(
				string Str
				)
			{
			// convert content from string to binary
			foreach(char Chr in Str) ObjectValueList.Add((byte) Chr);
			return;
			}

		internal void ObjectValueFormat
				(
				string FormatStr,
				params object[] List
				)
			{
			// format input arguments
			string Str = string.Format(NFI.PeriodDecSep, FormatStr, List);

			// convert content from string to binary
			foreach(char Chr in Str) ObjectValueList.Add((byte) Chr);
			return;
			}

		////////////////////////////////////////////////////////////////////
		// Convert resource dictionary to one String.
		// This method is called at the last step of document creation
		// from within PdfDocument.CreateFile(FileName).
		// it is relevant to page contents, X objects and tiled pattern
		// Return value is resource dictionary string.
		////////////////////////////////////////////////////////////////////

		internal string BuildResourcesDictionary
				(
				List<PdfObject> ResObjects, // list of resource objects for this contents
				bool AddProcSet // for page contents we need /ProcSet 
				)
			{
			// resource object list is empty
			// if there are no resources an empty dictionary must be returned
			if(ResObjects == null || ResObjects.Count == 0)
				{
				return AddProcSet ? "<</ProcSet [/PDF/Text]>>" : "<<>>";
				}

			// resources dictionary content initialization
			StringBuilder Resources = new StringBuilder("<<");

			// for page object
			if(AddProcSet) Resources.Append("/ProcSet [/PDF/Text/ImageB/ImageC/ImageI]\n");

			// add all resources
			char ResCodeType = ' ';
			foreach(PdfObject Resource in ResObjects)
				{
				// resource code is /Xnnn
				if(Resource.ResourceCode[1] != ResCodeType)
					{
					// terminate last type
					if(ResCodeType != ' ') Resources.Append(">>\n");

					// start new type
					ResCodeType = Resource.ResourceCode[1];
					Resources.Append(ResCodeStr[ResCodeLetter.IndexOf(ResCodeType)]);
					}

				// append resource code
				if(Resource.GetType() != typeof(PdfFont))
					{
					Resources.Append(string.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
					}
				else
					{
					PdfFont Font = (PdfFont) Resource;
					if(Font.FontResCodeUsed)
						Resources.Append(string.Format("{0} {1} 0 R", Font.ResourceCode, Font.ObjectNumber));
					if(Font.FontResGlyphUsed)
						Resources.Append(string.Format("{0} {1} 0 R", Font.ResourceCodeGlyph, Font.GlyphIndexFont.ObjectNumber));
					}
				}

			// terminate last type and resource dictionary
			Resources.Append(">>\n>>");

			// exit
			return Resources.ToString();
			}

		internal virtual void CloseObject()
			{
			return;
			}

		////////////////////////////////////////////////////////////////////
		// Write stream object to PDF file
		// Called by PdfDocument.CreateFile(FileName) method
		// to output one indirect stream PDF object.
		////////////////////////////////////////////////////////////////////
		internal void WriteToPdfFile()
			{
			// already done or not in file object
			if(FilePosition != 0 || XRefType != XRefObjType.InFile) return;

			// save file position for this object
			FilePosition = Document.PdfFile.BaseStream.Position;

			// write object header
			Document.PdfFile.WriteFormat("{0} 0 obj\n", ObjectNumber);

			// stream object
			if(ObjectType == ObjectType.Stream)
				{ 
				// convert byte list to array
				if(ObjectValueList.Count > 0) ObjectValueArray = ObjectValueList.ToArray();

				// object value is empty
				if(ObjectValueArray == null) ObjectValueArray = new byte[0];

				// compress the stream and update dictionary if successful
				if(!NoCompression && PdfDocument.CompressStream(ref ObjectValueArray)) Dictionary.Add("/Filter", "/FlateDecode");

				// encryption
				if(Document.Encryption != null)
					ObjectValueArray = Document.Encryption.EncryptByteArray(ObjectNumber, ObjectValueArray);

				// stream length
				Dictionary.AddInteger("/Length", ObjectValueArray.Length);

				// write dictionary
				Document.PdfFile.Write(Dictionary.ToByteArray());

				// write stream reserved word
				Document.PdfFile.WriteString("stream\n");

				// write content to pdf file
				Document.PdfFile.Write(ObjectValueArray);

				// write end of stream
				Document.PdfFile.WriteString("\nendstream\nendobj\n");
				}

			else
				{ 
				// write dictionary
				Document.PdfFile.Write(Dictionary.ToByteArray());

				// write end of object
				Document.PdfFile.WriteString("\nendobj\n");
				}

			// this indirect object was written to output file
			// tell the garbage collector that these objects are not used any more
			Dictionary = null;
			ObjectValueList = null;
			ObjectValueArray = null;
			return;
			}

		////////////////////////////////////////////////////////////////////
		// Write root object to PDF file
		////////////////////////////////////////////////////////////////////
		internal void WriteRootToPdfFile()
			{
			// convert root object from ObjStm to InFile
			XRefType = XRefObjType.InFile;

			// save file position for this object
			FilePosition = Document.PdfFile.BaseStream.Position;

			// write object header
			Document.PdfFile.WriteFormat("{0} 0 obj\n", ObjectNumber);

			// write dictionary
			Document.PdfFile.Write(Dictionary.ToByteArray());

			// write end of object
			Document.PdfFile.WriteString("\nendobj\n");
			return;
			}
		}
	}
